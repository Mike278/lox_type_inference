let {plus} = import "numeric.lox";

let elements = \list ->
    if list |> List.empty
    then .err(.empty_list)
    else .ok({
            first: list |> List.first,
            rest: list |> List.rest,
          })
;

let fold = \state, fn -> \list {
    let {first, rest} = list |> elements ?? return state;
    let new_state = fn(state, first);
    return rest |> fold(new_state, fn);
};

let try_fold = \initial, fn ->
  fold(
    .ok(initial),
    \state, element -> fn(state!, element),
  );

let map = \fn ->
    fold([], \state, element -> [..state, fn(element)]);

let try_map = \fn ->
  fold(
    .ok([]),
    \state, element -> .ok([
      ..state!,
      fn(element)!,
    ]),
  );

let reduce = \fn -> \list ->
  match list |> elements {
    .err(e) -> .err(e),
    .ok({first, rest}) -> .ok(rest |> fold(first, fn))
  };

let reverse =
    fold([], \state, element -> [element, ..state]);

let where = \fn ->
    fold([], \state, element -> if fn(element) then [..state, element] else state);

let enumerated = \list {
    let result = list |> fold(
        {index: 0, list: []},
        \{index, list}, element -> {
            index: index + 1,
            list: [ ..list, { element, index } ],
        }
    );
    return result.list;
};

let count_where = \predicate ->
    fold(0, \count, element -> if predicate(element) then count + 1 else count);

let sort = \list {
  let {first: x, rest: xs} = list |> elements ?? return [];
  let is_before = \e -> e < x;
  let is_after = \e -> e >= x;
  return [
    ..xs |> where(is_before) |> sort,
    x,
    ..xs |> where(is_after) |> sort
  ];
};

let zip = \list1, list2, fn {
  let l1 = list1 |> elements ?? return [];
  let l2 = list2 |> elements ?? return [];
  return [
      fn(l1.first, l2.first),
      ..zip(l1.rest, l2.rest, fn),
  ];
};

let zip_with_tail = \fn -> \list ->
  match list |> elements {
    .err(_) -> [],
    .ok({rest}) -> zip(list, rest, fn)
  };

let sum = reduce(plus);



let fold_until = \state, fn -> \list {
    let {first, rest} = list |> elements ?? return state;
    let step = fn(state, first);
    return match step {
        .continue(new_state) -> rest |> fold_until(new_state, fn),
        .break(final_state) -> final_state,
    };
};

let any = \predicate ->
    fold_until(
        false,
        \state, element ->
            if predicate(element)
            then .break(true)
            else .continue(state)
    );

let all = \predicate ->
    fold_until(
        true,
        \state, element ->
            if predicate(element)
            then .continue(state)
            else .break(false)
    );

let drop_at = \target_index -> \list ->
    list
        |> enumerated
        |> where(\{index} -> index != target_index)
        |> map(\{element} -> element);

let join = fold("", String.concat);

let element_at = \target_index -> \list ->
    list
        |> enumerated
        |> fold_until(
               .err(.out_of_bounds),
               \state, {index, element} ->
                   if index == target_index
                   then .break(.ok(element))
                   else .continue(state),
           );

let length = fold(0, \count, _ -> count + 1);

let is_empty = \list ->
    match list |> elements {
        .ok(_) -> false,
        .err(_) -> true,
    };
