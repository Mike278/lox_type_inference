let {plus} = import "numeric.lox";
let {empty, first, rest} = List;

let fold = \list, state, fn ->
    list \> empty ? state :
    fold(list \> rest, fn(state, list \> first), fn);

let map = \list, fn ->
    fold(list, [], \state, element -> [..state, fn(element)]);

let reduce = \list, fn ->
    fold(list \> rest, list \> first, fn);

let reverse = \list ->
    fold(list, [], \state, element -> [element, ..state]);

let where = \list, fn ->
    fold(list, [], \state, element ->
        fn(element) ? [..state, element] : state);

let countWhere = \list, predicate ->
    fold(list, 0, \count, element -> predicate(element) ? count + 1 : count);

let sort = \list {
  if list \> empty then return [];
  let x = list \> first;
  let xs = list \> rest;
  let isBefore = \e -> e < x;
  let isAfter = \e -> e >= x;
  return [
    ..xs \> where(_, isBefore) \> sort,
    x,
    ..xs \> where(_, isAfter) \> sort
  ];
};

let zip = \l1, l2, fn ->
    (l1 \> empty) or
    (l2 \> empty) ? [] :
    [
        fn(l1 \> first, l2 \> first),
        ..zip(l1 \> rest, l2 \> rest, fn)
    ];

let zipWithTail = \list, fn ->
    zip(list, list \> rest, fn);

let sum = reduce(_, plus);



let foldUntil = \list, state, fn {
    if list \> empty then return state;
    return match fn(state, list \> first) {
        .Continue newState -> foldUntil(list \> rest, newState, fn),
        .Break finalState -> finalState,
    };
};

let any = \list, predicate ->
    foldUntil(
        list,
        false,
        \state, element ->
            predicate(element)
                ? .Break(true)
                : .Continue(state)
    );

let all = \list, predicate ->
    foldUntil(
        list,
        true,
        \state, element ->
            predicate(element)
                ? .Continue(state)
                : .Break(false)
    );
