let {plus} = import "numeric.lox";
let {empty, first, rest} = List;

let fold = \state, fn -> \list {
    if list \> empty then return state;
    let element = list \> first;
    let new_state = fn(state, element);
    return list \> rest \> fold(new_state, fn);
};

let map = \fn -> \list ->
    list \> fold([], \state, element -> [..state, fn(element)]);

let reduce = \fn -> \list ->
    list \> rest \> fold(list \> first, fn);

let reverse = \list ->
    list \> fold([], \state, element -> [element, ..state]);

let where = \fn -> \list ->
    list \> fold([], \state, element ->
        fn(element) ? [..state, element] : state);

let enumerated = \list {
    let result = list \> fold(
        {index: 0, list: []},
        \state, element -> {
            index: state.index + 1,
            list: [
                ..state.list,
                {
                    element: element,
                    index: state.index,
                }
            ],
        }
    );
    return result.list;
};

let count_where = \predicate -> \list ->
    list \> fold(0, \count, element -> predicate(element) ? count + 1 : count);

let sort = \list {
  if list \> empty then return [];
  let x = list \> first;
  let xs = list \> rest;
  let is_before = \e -> e < x;
  let is_after = \e -> e >= x;
  return [
    ..xs \> where(is_before) \> sort,
    x,
    ..xs \> where(is_after) \> sort
  ];
};

let zip = \l1, l2, fn ->
    (l1 \> empty) or
    (l2 \> empty) ? [] :
    [
        fn(l1 \> first, l2 \> first),
        ..zip(l1 \> rest, l2 \> rest, fn)
    ];

let zip_with_tail = \fn -> \list ->
    zip(list, list \> rest, fn);

let sum = reduce(plus);



let fold_until = \state, fn -> \list {
    if list \> empty then return state;
    let step = fn(state, list \> first);
    return match step {
        .Continue new_state -> list \> rest \> fold_until(new_state, fn),
        .Break final_state -> final_state,
    };
};

let any = \predicate -> \list ->
    list \> fold_until(
        false,
        \state, element ->
            predicate(element)
                ? .Break(true)
                : .Continue(state)
    );

let all = \predicate -> \list ->
    list \> fold_until(
        true,
        \state, element ->
            predicate(element)
                ? .Continue(state)
                : .Break(false)
    );

let drop_at = \index -> \list ->
    list
        \> enumerated
        \> where(\x -> x.index != index)
        \> map(\x -> x.element);
