let {plus} = import "numeric.lox";
let {empty, first, rest} = List;

let fold = \list, state, fn ->
    list \> empty ? state :
    fold(list \> rest, fn(state, list \> first), fn);

let map = \list, fn ->
    fold(list, [], \state, element -> [..state, fn(element)]);

let reduce = \list, fn ->
    fold(list \> rest, list \> first, fn);

let reverse = \list ->
    fold(list, [], \state, element -> [element, ..state]);

let where = \list, fn ->
    fold(list, [], \state, element ->
        fn(element) ? [..state, element] : state);

let count_where = \list, predicate ->
    fold(list, 0, \count, element -> predicate(element) ? count + 1 : count);

let sort = \list {
  if list \> empty then return [];
  let x = list \> first;
  let xs = list \> rest;
  let is_before = \e -> e < x;
  let is_after = \e -> e >= x;
  return [
    ..xs \> where(_, is_before) \> sort,
    x,
    ..xs \> where(_, is_after) \> sort
  ];
};

let zip = \l1, l2, fn ->
    (l1 \> empty) or
    (l2 \> empty) ? [] :
    [
        fn(l1 \> first, l2 \> first),
        ..zip(l1 \> rest, l2 \> rest, fn)
    ];

let zip_with_tail = \list, fn ->
    zip(list, list \> rest, fn);

let sum = reduce(_, plus);



let fold_until = \list, state, fn {
    if list \> empty then return state;
    return match fn(state, list \> first) {
        .Continue new_state -> fold_until(list \> rest, new_state, fn),
        .Break final_state -> final_state,
    };
};

let any = \list, predicate ->
    fold_until(
        list,
        false,
        \state, element ->
            predicate(element)
                ? .Break(true)
                : .Continue(state)
    );

let all = \list, predicate ->
    fold_until(
        list,
        true,
        \state, element ->
            predicate(element)
                ? .Continue(state)
                : .Break(false)
    );
