let {fold, map, join} = import "util/lists.lox";

let input = [
    {arg1: "forward", arg2: 5},
    {arg1: "down",    arg2: 5},
    {arg1: "forward", arg2: 8},
    {arg1: "up",      arg2: 3},
    {arg1: "down",    arg2: 8},
    {arg1: "forward", arg2: 2},
];

let scale_by = \factor -> \{x, y} -> {
    x: x * factor,
    y: y * factor,
};

let add = \a, b -> {
    x: a.x + b.x,
    y: a.y + b.y,
};



/////// Part 1 ///////

let offset_for_direction = \dir {
    if dir == "up"      then return {y: -1, x: 0};
    if dir == "down"    then return {y: 1, x: 0};
    if dir == "forward" then return {y: 0, x: 1};
    print ["unknown direction: '", dir, "' falling back to no-op"] \> join;
    return {y: 0, x: 0};
};

let to_movement = \instr ->
    offset_for_direction(instr.arg1)
    \> scale_by(instr.arg2)
;

let part_1 = input
    \> map(to_movement)
    \> fold({y: 0, x: 0}, add)
    \> \{x, y} -> x * y
;
print part_1;
assert part_1 == 150;

/////// Part 2 ///////

let update = \state, instr {

    let {aim, pos} = match state {
        .Err(_) -> return state,
        .Ok(x) -> x,
    };

    let {
        arg1: dir,
        arg2: mag,
    } = instr;

    // todo: fix type checking bug that prevents using record updates here

    if dir == "down" then return .Ok({
        aim: aim + mag,
        pos,
    });

    if dir == "up" then return .Ok({
        aim: aim - mag,
        pos,
    });

    if dir == "forward" then return .Ok({
        aim,
        pos: {
            x: pos.x + mag,
            y: pos.y + mag * aim
        },
    });

    return .Err(["unknown direction: '", dir, "' falling back to no-op"] \> join);
};

let initial = .Ok({
    aim: 0,
    pos: {x: 0, y: 0},
});
let result = input \> fold(initial, update);
let part_2 = match result {
    .Ok({pos: {x, y}}) -> x * y,
    .Err(_) -> -1,
};

print part_2;
assert part_2 == 900;
